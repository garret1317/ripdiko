#!/usr/bin/env ruby

require 'net/https'
require 'uri'
require 'pathname'
require 'base64'
require 'open-uri'
require 'nokogiri'
require 'date'
require 'fileutils'

module Notifier
  SCRIPTS = ENV['RIPDIKO_SCRIPTS'] || "#{ENV['HOME']}/.ripdiko/scripts"

  def notify(hook, args)
    script = "#{SCRIPTS}/#{hook.to_s}"
    if File.executable?(script)
      system build_environment(args), script
    end
  end

  def build_environment(args)
    env = Hash.new
    walk_down(env, args, "RIPDIKO")
    env
  end

  def walk_down(env, value, prefix)
    case value
    when Hash
      value.each do |key, value|
        walk_down(env, value, "#{prefix}_#{key.upcase}")
      end
    when Array
      value.each_with_index do |value, i|
        walk_down(env, value, "#{prefix}_#{i}")
      end
    else
      env[prefix] = value.to_s
    end
  end
end

class DownloadTask
  include Notifier

  PLAYER_URL = "https://radiko.jp/apps/js/flash/myplayer-release.swf"
  TMPDIR = ENV['TMPDIR'] || '/tmp'

  attr_accessor :station, :buffer, :outdir

  def initialize(station = nil, duration = 1800, *args)
    unless station
      abort "Usage: ripdiko [station-id]"
    end
    @station = station
    @duration = duration
    @buffer = ENV['RIPDIKO_BUFFER'] || 60
    @outdir = ENV['RIPDIKO_OUTDIR'] || "#{ENV['HOME']}/Music/Radiko"
    @output = ENV['RIPDIKO_OUTPUT'] == nil ? "file" : ENV['RIPDIKO_OUTPUT']
  end

  def authenticate
    res = fetch 'https://radiko.jp/apps/js/playerCommon.js?_=20171113', {}
    if /new RadikoJSPlayer\(.*?'pc_html5',\s*'(\w+)'/ === res.body
      auth_key = $1
    else
      abort "retrieving auth_key from playerCommon.js failed"
    end

    res = fetch "https://radiko.jp/v2/api/auth1",
      'X-Radiko-App' => "pc_html5",
      'X-Radiko-App-Version' => "0.0.1",
      'X-Radiko-User' => "dummy_user",
      'X-Radiko-Device' => "pc"

    unless token = res['X-Radiko-AuthToken']
      abort "auth1 failed"
    end

    length = res['X-Radiko-KeyLength'].to_i
    offset = res['X-Radiko-KeyOffset'].to_i
    partial_key = Base64.strict_encode64(auth_key.byteslice(offset, length))

    res = fetch "https://radiko.jp/v2/api/auth2",
      'X-Radiko-User' => "dummy_user",
      'X-Radiko-Device' => "pc",
      'X-Radiko-Authtoken' => token,
      'X-Radiko-Partialkey' => partial_key

    if /^([A-Z0-9]+),/ === res.body
      [token, $1]
    else
      abort "auth2 failed. Outside Japan?"
    end
  end

  def val(node, xpath)
    node.xpath(".//#{xpath}").first.content
  end

  def parse_time(str)
    DateTime.strptime("#{str}+0900", "%Y%m%d%H%M%S%Z").to_time
  end

  def now_playing(station, area)
    now = Time.now
    doc = Nokogiri::XML(URI.open("https://radiko.jp/v2/api/program/now?area_id=#{area}"))

    node = doc.xpath(%Q|//station[@id="#{station}"]|).first
    node.xpath(".//prog").each do |prog|
      from, to = parse_time(prog[:ft]), parse_time(prog[:to])
      start_time = now.to_i + buffer
      if from.to_i <= start_time && start_time < to.to_i
        return Program.new(
          id: "#{prog[:ft]}-#{station}",
          station: val(node, :name),
          title: val(prog, :title),
          from: from,
          to: to,
          duration: prog[:dur].to_i,
          subtitle: val(prog, :sub_title),
          performer: val(prog, :pfm),
          info: val(prog, :info),
        )
      end
    end
  end

  def run
    token, area = authenticate
    program = now_playing(station, area)

    duration = program.recording_duration + buffer

    tempfile = "#{TMPDIR}/#{program.id}.m4a"

    case @output
    when "fifo" then
      require 'mkfifo'
      tempfile = "#{TMPDIR}/fifo.m4a"
      if File.exist? tempfile
        FileUtils.rm tempfile
      end
      File.mkfifo tempfile
    when "stdout"
      tempfile = "-f m4a -"
    end

    puts "Streaming #{program.title} ~ #{program.to.strftime("%H:%M")} (#{duration}s)"
    puts "Ripping audio file to #{tempfile}"

    command = %W(
      rtmpdump --live --quiet
      -r rtmpe://f-radiko.smartstream.ne.jp
      --playpath simul-stream.stream
      --app #{station}/_definst_
      -W #{PLAYER_URL}
      -C S:"" -C S:"" -C S:"" -C S:#{token}
      --live --stop #{duration} -o - |
      ffmpeg -y -i - -vn
      -loglevel error
      -metadata author="#{program.performer}"
      -metadata artist="#{program.station}"
      -metadata title="#{program.title} #{program.effective_date.strftime}"
      -metadata album="#{program.title}"
      -metadata genre=Radio
      -metadata year="#{program.effective_date.year}"
      -c copy
      #{tempfile}
    )

    system command.join(" ")

    case @output
    when "file" then
      FileUtils.mkpath(outdir)
      File.rename tempfile, "#{outdir}/#{program.id}.m4a"

      notification = {
        :program => {
          title: program.title,
          station: program.station,
          duration: program.duration,
          subtitle: program.subtitle,
          performer: program.performer,
        },
        :recording_time => duration
      }

      notify :recording_finished, notification
    when "fifo"
      FileUtils.rm tempfile
    end
  end

  def fetch(url, headers)
    uri = URI.parse url

    http = Net::HTTP.new uri.host, uri.port
    http.use_ssl = true if uri.scheme == 'https'

    req = Net::HTTP::Get.new uri.request_uri
    headers.each do |k,v|
      req[k] = v
    end

    http.request req
  end

  def abort(msg)
    puts msg
    exit 1
  end
end

class Program
  attr_accessor :id, :station, :title, :from, :to, :duration, :subtitle, :performer, :info
  def initialize(args = {})
    args.each do |k, v|
      send "#{k}=", v
    end
  end

  def effective_date
    time = from.hour < 5 ? from - 24 * 60 * 60 : from
    Date.new(time.year, time.month, time.day)
  end

  def recording_duration
    (to - Time.now).to_i
  end
end

DownloadTask.new(*ARGV).run
